RocketMQ 简单消息示例，包含消息发送和消费两部分内容。
# 1.导入依赖
## Maven 工程
```xml
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-client</artifactId>
    <version>4.5.0</version>
</dependency>
```
## Gradle 工程
```groovy
compile 'org.apache.rocketmq:rocketmq-client:4.5.0'
```

# 2.发送消息
## 2.1 同步模式
同步模式发送消息，broker 接受消息成功后才会向 producer 返回成功。发送消息的可靠性得以保证的同时，也会产生等待 broker 响应的延时。

```java
public class SyncProducer {
    public static void main(String[] args) throws Exception {
        // 实例化消息生产者 Producer
        DefaultMQProducer producer = new DefaultMQProducer("sync_msg_group");
        // 设置 nameserver地址
        producer.setNamesrvAddr("localhost:9876");
        // 启动 producer 实例
        producer.start();
        for (int i = 0; i < 100; i++) {
            // 创建消息，并制定 topic/tag和消息体
            Message message = new Message("TopicTest", "TagA", ("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
            // 发送消息到一个 broker
            SendResult sendResult = producer.send(message);
            // 输出发送结果
            System.out.printf("%s%n", sendResult);
        }
        // 关闭 producer 实例
        producer.shutdown();
    }
}
```

> 首次启动可能会报异常，常见异常解决方案参考：RocketMQ 常见异常

## 2.2 异步模式
异步模式下 producer不会等待 broker 响应结果，适用于对响应时间敏感的业务场景。
```java
public class AsyncProducer {
    
    public static void main(String[] args) throws Exception{
        // 实例化消息生产者 Producer
        DefaultMQProducer producer = new DefaultMQProducer("async_msg_group");
        // 设置 NameServer 地址
        producer.setNamesrvAddr("localhost:9876");
        // 启动 Producer
        producer.start();
        producer.setRetryTimesWhenSendAsyncFailed(0);
        for (int i = 0; i < 100; i++) {
            final int index = i;
            // 创建消息体
            Message message = new Message("TopicTest", "TagA", "Hello world".getBytes(RemotingHelper.DEFAULT_CHARSET));
            // 接收异步返回结果回调
            producer.send(message, new SendCallback() {
                @Override
                public void onSuccess(SendResult sendResult) {
                    System.out.printf("发送结果:%s\n", sendResult);
                }

                @Override
                public void onException(Throwable throwable) {
                    System.out.printf("发送异常:%s\n", throwable);
                }
            });
            // 这里暂停一秒的目的是为了防止这个异常出现
            // org.apache.rocketmq.client.exception.MQClientException: 
            // The producer service state not OK, SHUTDOWN_ALREADY
            TimeUnit.SECONDS.sleep(1);
        }
        // 关闭 Producer
        producer.shutdown();
    }
}
```
## 2.3 单向模式
此模式适用于不关心发送结果的场景，例如日志发送。
```java
public class OneWayProducer {
    public static void main(String[] args) throws Exception{
        // 实例化消息生产者 Producer
        DefaultMQProducer producer = new DefaultMQProducer("one_way_msg_group");
        // 设置 NameServer 地址
        producer.setNamesrvAddr("localhost:9876");
        // 启动 Producer
        producer.start();
        for (int i = 0; i < 100; i++) {
            // 创建消息体
            Message message = new Message("TopicTest", "TagA", "Hello world".getBytes(RemotingHelper.DEFAULT_CHARSET));
            // 发送单向消息,没有任何返回结果
            producer.sendOneway(message);
        }
        // 关闭 Producer
        producer.shutdown();
    }
}
```

## 2.4 批量模式
批量发送消息能显著提高传递小消息的性能。限制是这些批量消息应该有相同的topic，相同的waitStoreMsgOK，而且不能是延时消息。此外，这一批消息的总大小不应超过4MB。

```java
public class BatchProducer {
    public static void main(String[] args) throws Exception {
        // 实例化消息生产者 Producer
        DefaultMQProducer producer = new DefaultMQProducer("sync_msg_group");
        // 设置 nameserver地址
        producer.setNamesrvAddr("localhost:9876");
        // 启动 producer 实例
        producer.start();

        List<Message> messageList = IntStream.range(0, 10).mapToObj(r -> {
            // 创建消息,并制定 topic/tag和消息体
            Message message = null;
            try {
                message = new Message("TopicTest", "TagA", ("Hello RocketMQ " + r).getBytes(RemotingHelper.DEFAULT_CHARSET));
            } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
            }
            return message;
        }).collect(Collectors.toList());

        // 发送消息到broker
        SendResult sendResult = producer.send(messageList);
        // 输出发送结果
        System.out.printf("%s%n", sendResult);

        // 关闭 producer 实例
        producer.shutdown();
    }
}
```

# 3.消费消息
## 3.1 负载均衡模式
消费者采用负载均衡方式消费消息，多个消费者共同消费队列消息，每个消费者处理的消息不同。

```java
public class ClusteringConsumer {
    public static void main(String[] args) throws Exception{
        // 实例化消息消费者
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("clustering_consumer_group");
        // 设置 nameserver
        consumer.setNamesrvAddr("localhost:9876");
        // 订阅 Topic
        consumer.subscribe("TopicTest", "TagA");
        // 设置负载均衡消费模式
        consumer.setMessageModel(MessageModel.CLUSTERING);
        // 注册回调函数,处理消息
        consumer.registerMessageListener((MessageListenerConcurrently) (list, consumeConcurrentlyContext) -> {
            System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), list);
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        });
        // 启动消费者
        consumer.start();
    }
}
```
> IDEA 中设置同一个 main 方法启动多次：Edit Configurations -> Application -> ClusteringConsumer -> 右上角勾选 Allow parallel run
## 3.2 广播模式
广播的方式消费消息，每个消费者消费的消息都是相同的。
```java
public class BroadcastingConsumer {
    public static void main(String[] args) throws Exception{
        // 设置生产者
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("broadcasting_consumer_group");
        // 设置nameserver
        consumer.setNamesrvAddr("localhost:9876");
        // 订阅 topic
        consumer.subscribe("TopicTest", "TagA");
        // 设置广播模式
        consumer.setMessageModel(MessageModel.BROADCASTING);
        // 注册回调函数,处理消息
        consumer.registerMessageListener((MessageListenerConcurrently) (list, consumeConcurrentlyContext) -> {
            System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), list);
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        });
        consumer.start();
    }
}
```

# 参考资料
- [http://rocketmq.apache.org/docs/simple-example/](http://rocketmq.apache.org/docs/simple-example/)
- [http://rocketmq.apache.org/docs/batch-example/](http://rocketmq.apache.org/docs/batch-example/)
- [RocketMQ 基础教程](https://www.bilibili.com/video/BV1ta4y1x729/)
