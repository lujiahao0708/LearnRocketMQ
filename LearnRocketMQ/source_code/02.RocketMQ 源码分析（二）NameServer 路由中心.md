# 1.NameServer 概览
RocketMQ早期路由功能是由 zookeeper 实现的，后来rocketmq为了追求性能，自己实现了一个性能更高效且实现简单的路由中心NameServer，而且可以通过部署多个路由节点实现高可用，但它们之间并不能互相通信，这也就会导致在某一个时刻各个路由节点间的数据并不完全相同，但数据某个时刻不一致并不会导致消息发送不了，这也是rocketmq追求简单高效的一个做法。

NameServer 本身的高可用是通过部署多台 NameServer 来实现，但彼此之间不通讯，也就是集群中多台 NameServer 服务器之间在某一个时刻的数据并不完全相同，但这并不会对消息发送造成影响，这也是NameServer设计的一个亮点，这样设计的目的是为了降低 NameServer 实现的复杂度，在消息发送端提供容错机制保证消息发送的可用性。总之，RocketMQ 设计追求简单高效。


![](https://raw.githubusercontent.com/lujiahao0708/PicRepo/master/blogPic/RocketMQ/RocketMQ%E6%BA%90%E7%A0%81/NameServer%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png)

大体介绍下主要类的作用：
- NamesrvStartup 启动类
- NamesrvController 核心控制器
- RouteInfoManager 路由信息表
- KVConfigManager
- DefaultRequestProcessor

# 2.NameServer 启动
NamesrvStartup 为启动类，main 方法为启动方法，内部调用 main0 方法。

代码位置：`org.apache.rocketmq.namesrv.NamesrvStartup#main0`

```java
public static NamesrvController main0(String[] args) {
    try {
        // 创建 NamesrvController
        NamesrvController controller = createNamesrvController(args);
        // 启动 NamesrvController
        start(controller);
        String tip = "The Name Server boot success. serializeType=" + RemotingCommand.getSerializeTypeConfigInThisServer();
        log.info(tip);
        System.out.printf("%s%n", tip);
        return controller;
    } catch (Throwable e) {
        e.printStackTrace();
        System.exit(-1);
    }
    return null;
}
```
NameServer 的启动主体流程很简单，内部具体实现我们下面一一解析。

## 2.1 创建 NamesrvController
创建 NamesrvController 分为三步：
- 创建 commandLine 命令行对象
- 解析配置文件填充 Config 对象
- 创建 NamesrvController

代码位置：`org.apache.rocketmq.namesrv.NamesrvStartup#createNamesrvController`

### 2.1.1 创建 commandLine 命令行对象
RocketMQ 使用 Apache Commons CLI 命令行解析工具，根据 NameServer 启动时 mqnamesrv 命令传递的参数生成 commandLine 命令行对象，这里了解即可。
```java
Options options = ServerUtil.buildCommandlineOptions(new Options());
commandLine = ServerUtil.parseCmdLine("mqnamesrv", args, buildCommandlineOptions(options), new PosixParser());
if (null == commandLine) {
    System.exit(-1);
    return null;
}
```

### 2.1.2 解析配置文件填充 Config 对象
随后使用 commandLine 对象解析命令行 -c 参数指定的配置文件，加载到属性对象并填充到 namesrvConfig 和 nettyServerConfig 对象中。
```java
// 创建 NamesrvConfig 和 NettyServerConfig 对象
final NamesrvConfig namesrvConfig = new NamesrvConfig();
final NettyServerConfig nettyServerConfig = new NettyServerConfig();
// 设置 NameServer 服务端口号
nettyServerConfig.setListenPort(9876);
// 解析命令行 -c 参数指定配置文件
if (commandLine.hasOption('c')) {
    String file = commandLine.getOptionValue('c');
    if (file != null) {
        InputStream in = new BufferedInputStream(new FileInputStream(file));
        properties = new Properties();
        properties.load(in);
        // 属性填充到 namesrvConfig 和 nettyServerConfig
        MixAll.properties2Object(properties, namesrvConfig);
        MixAll.properties2Object(properties, nettyServerConfig);

        namesrvConfig.setConfigStorePath(file);
        System.out.printf("load config properties file OK, %s%n", file);
        in.close();
    }
}
```

### 2.1.3 创建 NamesrvController
```java
// 根据 NamesrvConfig 和 NettyServerConfig 创建 NamesrvController
final NamesrvController controller = new NamesrvController(namesrvConfig, nettyServerConfig);
// 重新注册配置，防止丢失
// remember all configs to prevent discard
controller.getConfiguration().registerConfig(properties);
```

**NamesrvConfig属性**

```java
// rocketmq主目录，需要在启动时配置
private String rocketmqHome = System.getProperty(MixAll.ROCKETMQ_HOME_PROPERTY, System.getenv(MixAll.ROCKETMQ_HOME_ENV));
// NameServer存储KV配置属性的持久化路径
private String kvConfigPath = System.getProperty("user.home") + File.separator + "namesrv" + File.separator + "kvConfig.json";
// nameServer默认配置文件路径
private String configStorePath = System.getProperty("user.home") + File.separator + "namesrv" + File.separator + "namesrv.properties";
private String productEnvName = "center";
private boolean clusterTest = false;
// 是否支持顺序消息
private boolean orderMessageEnable = false;
```

**NettyServerConfig属性**

```java
// NameServer监听端口，该值默认会被初始化为9876
private int listenPort = 8888;
// Netty业务线程池线程个数
private int serverWorkerThreads = 8;
// Netty public任务线程池线程个数，Netty网络设计，根据业务类型会创建不同的线程池，比如处理消息发送、消息消费、心跳检测等。如果该业务类型未注册线程池，则由public线程池执行。
private int serverCallbackExecutorThreads = 0;
// IO线程池个数，主要是NameServer、Broker端解析请求、返回相应的线程个数，这类线程主要是处理网路请求的，解析请求包，然后转发到各个业务线程池完成具体的操作，然后将结果返回给调用方;
private int serverSelectorThreads = 3;
// send oneway消息请求并发读（Broker端参数）
private int serverOnewaySemaphoreValue = 256;
// 异步消息发送最大并发度
private int serverAsyncSemaphoreValue = 64;
// 网络连接最大的空闲时间，默认120s
private int serverChannelMaxIdleTimeSeconds = 120;
// 网络socket发送缓冲区大小
private int serverSocketSndBufSize = NettySystemConfig.socketSndbufSize;
// 网络接收端缓存区大小
private int serverSocketRcvBufSize = NettySystemConfig.socketRcvbufSize;
// ByteBuffer是否开启缓存
private boolean serverPooledByteBufAllocatorEnable = true;
// 是否启用Epoll IO模型
private boolean useEpollNativeSelector = false;
```

> namesrvConfig 和 nettyServerConfig 中的属性都有默认值，因此在不指定配置文件的情况下 NameServer 也可以正常启动。
> 需要注意：namesrvConfig 中的 rocketmqHome 属性没有默认值，因此在上一篇配置环境时设置 `ROCKETMQ_HOME=/Users/xxx/github/rocketmq`。

## 2.2 启动 NamesrvController
启动 NamesrvController 分为三步：

- NamesrvController 初始化
- 注册钩子函数
- 启动 netty 服务

代码位置：`org.apache.rocketmq.namesrv.NamesrvStartup#start`

```java
public static NamesrvController start(final NamesrvController controller) throws Exception {
    if (null == controller) {
        throw new IllegalArgumentException("NamesrvController is null");
    }

    // NamesrvController 初始化
    boolean initResult = controller.initialize();
    if (!initResult) {
        controller.shutdown();
        System.exit(-3);
    }

    // 注册钩子函数，JVM进程退出时，优雅地关闭服务并释放资源
    Runtime.getRuntime().addShutdownHook(new ShutdownHookThread(log, new Callable<Void>() {
        @Override
        public Void call() throws Exception {
            controller.shutdown();
            return null;
        }
    }));

    // 启动 netty 服务
    controller.start();
    return controller;
}
```

### 2.2.1 NamesrvController 初始化
首先看下初始化的详细实现，代码位置：`org.apache.rocketmq.namesrv.NamesrvController#initialize`

```java
public boolean initialize() {
    // 加载kv配置
    this.kvConfigManager.load();
    // 创建Netty网络服务对象
    this.remotingServer = new NettyRemotingServer(this.nettyServerConfig, this.brokerHousekeepingService);

    this.remotingExecutor =
        Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), new ThreadFactoryImpl("RemotingExecutorThread_"));

    this.registerProcessor();
    // 定时任务 延迟5s启动,每隔10s扫描一次Broker，移除不活跃的Broker
    this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
        @Override
        public void run() {
            NamesrvController.this.routeInfoManager.scanNotActiveBroker();
        }
    }, 5, 10, TimeUnit.SECONDS);
    // 定时任务 延迟2s启动,每隔10min打印一次KV配置
    this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
        @Override
        public void run() {
            NamesrvController.this.kvConfigManager.printAllPeriodically();
        }
    }, 1, 10, TimeUnit.MINUTES);

    ......
    return true;
}
```

这个方法主要是针对 controller 进行初始化操作，比较重要的操作是每隔 10s 扫描 broker 并移除不活跃的broker，这里对 broker 的扫描和移除操作会在后面详细讲解。

### 2.2.2 注册钩子函数
注册钩子函数，用于JVM进程关闭时，优雅地关闭 Netty 服务并释放线程池等资源。这种写法在 JVM 正常退出情况下可以正确执行，但当 JVM 异常退出时就无法正确执行。

```java
Runtime.getRuntime().addShutdownHook(new ShutdownHookThread(log, new Callable<Void>() {
    @Override
    public Void call() throws Exception {
        controller.shutdown();
        return null;
    }
}));
```

### 2.2.3 启动 Netty 服务
代码位置：`org.apache.rocketmq.namesrv.NamesrvController#start`

RocketMQ 底层是通过 Netty 进行通信的，因此在 controller 启动的最后一步是将 Netty 服务启动。

```java
public void start() throws Exception {
    this.remotingServer.start();

    if (this.fileWatchService != null) {
        this.fileWatchService.start();
    }
}
```

# 3.NameServer 路由注册

# 4.NameServer 路由删除

# 5.NameServer 路由发现


# 参考资料
- 《RocketMQ 技术内幕》
- [RocketMQ 源码解析](https://www.bilibili.com/video/BV1Hp4y1D7bJ)