# 前言

Redis提供了两种持久化方式：

- RDB持久化（快照）

- AOF持久化（追加 Append-only file 文件）

# 1.RDB（Redis DataBase）
## 1.1 简介
在指定的时间间隔内将内存中的数据集快照写入磁盘，恢复时是将快照文件直接读到内存里。Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效。RDB 的缺点是最后一次持久化后的数据可能丢失。

> Fork 的原理是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。因此 RDB 的方式会导致内存占用两倍膨胀，从而对性能造成影响。

## 1.2 配置
> 参考[Redis 配置文件解析]() 中关于 `SNAPSHOTTING` 的详细解析。

```
save 900 1：表示900 秒内如果至少有 1 个 key 的值变化，则保存
save 300 10：表示300 秒内如果至少有 10 个 key 的值变化，则保存
save 60 10000：表示60 秒内如果至少有 10000 个 key 的值变化，则保存
dbfilename ：设置快照的文件名，默认是 dump.rdb。
dir：设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。使用上面的 dbfilename 作为保存的文件名。
```

> 停止 RDB 备份</br>
> 1.修改配置文件，全部注释 save 配置，然后重启 redis 即可</br>
> 2.执行命令：`redis-cli config set save ""`

## 1.3 触发 RDB
- SAVE：保存内存数据，全部阻塞，不推荐。
  - save命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在Redis服务器阻塞期间，服务器不能处理任何命令请求。
- BGSAVE：Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求。
  - bgsave 命令原理是派生一个子进程，子进程将数据写入临时 RDB 文件中，完成后新的 RDB 文件会替换旧的 RDB ，并将旧 RDB 文件删除。
  - 可以通过 lastsave 命令获取最后一次成功执行快照的时间。
- FLUSHALL：也会产生 dump.rdb 文件，但由于清空了内存中的数据，因此文件也为空。

## 1.4 恢复数据
将备份文件 dump.rdb 拷贝或者移动到 redis 安装目录并启动服务即可，redis 会自动恢复数据。

## 1.5 RDB 优缺点
- 优点
    - RDB 是压缩文件，适合大规模的数据恢复
    - 对数据完整性和一致性要求不高
- 劣势
    - RDB 原理是在一定间隔时间做一次备份，如果Redis 意外宕机，会丢失最后一次快照后的所有修改
    - 数据量较大时，Fork 过程非常耗时，同时内存中的数据被克隆了一份，导致内存占用翻倍从而影响性能

# 2.AOF（Append Only File）
## 2.1 简介
以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，即 redis 重启时就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。

## 2.2 配置
> 参考[Redis 配置文件解析]() 中关于 `APPEND ONLY MODE` 的详细解析。

```
appendonly：开启 AOF 配置。
appendfilename ：aof文件名，默认是"appendonly.aof"
appendfsync：aof持久化策略的配置；no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快；always表示每次写入都执行fsync，以保证数据同步到磁盘；everysec表示每秒执行一次fsync，可能会导致丢失这1s数据
auto-aof-rewrite-percentage：默认值为100。aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。
auto-aof-rewrite-min-size：64mb。设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写。
```

## 2.3 触发 AOF
修改配置文件中 `appendonly no`，改为 yes 即可启动 AOF 备份。

AOF 持久化策略的配置有三种
- no 表示不执行 fsync，由操作系统保证数据同步到磁盘，速度最快；
- always 表示每次写入都执行 fsync，以保证数据同步到磁盘；
- everysec 表示每秒执行一次 fsync，可能会导致丢失这1s数据

推荐使用 everysec 模式，兼顾性能和数据完整性
## 2.4 恢复数据
- 修改默认的appendonly no，改为yes
- 将 aof 文件复制到对应目录，如果文件被破坏，运行命令 `redis-check-aof --fix` 进行修复
- 重启 redis 即可恢复数据

## 2.5 AOF 优缺点
- 优点
  - 多种同步策略，方便灵活
  - AOF 文件以 Redis 协议格式保存，具有较高的易读性
- 缺点
  - 相同数据集的数据而言 AOF 文件要远大于 RDB 文件，恢复速度慢于 RDB
  - 配置不同的 fsync 策略，AOF 运行效率可能要慢于 RDB

## 2.6 AOF 重写
AOF 采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当 AOF 文件的大小超过所设定的阈值时，Redis 就会启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集。

### 2.6.1 重写原理
AOF 文件持续增长而过大时，会 fork 出一条新进程来将文件重写(也是先写临时文件最后再 rename)，遍历新进程的内存中数据，每条记录有一条的 Set 语句。重写 AOF 文件的操作，并没有读取旧的 AOF 文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的 AOF 文件，这点和快照有点类似。

### 2.6.2 重写触发机制
Redis 会记录上次重写时的 AOF 大小，默认配置是当 AOF 文件大小是上次 rewrite 后大小的一倍且文件大于64M时触发。由配置文件中 `auto-aof-rewrite-percentage` 和 `auto-aof-rewrite-min-size` 两个配置决定。

> 也可以通过命令 `BGREWRITEAOF` 手动触发

# 3. RDB 和 AOF 总结
- RDB 持久化方式能够在指定的时间间隔能对你的数据进行快照存储
- AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF 命令以 Redis 协议追加保存每次写的操作到文件末尾。Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。
- 如果仅仅使用 Redis 作为缓存服务，可以不使用任何持久化方式。
- 同时开启两种持久化方式，当 Redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整，RDB 的数据不实时，同时使用两者时服务器重启也只会找 AOF 文件。建议不要只使用 AOF ，因为 RDB 更适合用于备份数据库( AOF 在不断变化不好备份)，快速重启，而且不会有 AOF 可能潜在的 bug，留着作为一个万一的手段。
- 如果 Enalbe AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只加载自己的AOF 文件就可以了。代价一是带来了持续的 IO，二是 AOF rewrite 的最后将重写过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少 AOF rewrite 的频率，AOF重写的基础大小默认值 64M 太小了，可以设到 5G 以上。默认超过原大小 100% 大小时重写可以改到适当的数值。