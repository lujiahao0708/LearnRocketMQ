# 1.简介
可以一次执行多个命令，本质是一组命令的集合。一个事务中的 所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不许加塞。

一个队列中，一次性、顺序性、排他性的执行一系列命令

# 2.常用命令
- MULTI：标记一个事务块的开始。随后的指令将在执行EXEC时作为一个原子执行。
- EXEC：执行所有 MULTI 之后发出的命令
- DISCARD：丢弃所有 MULTI 之后发的命令
- WATCH：标记所有指定的key 被监视起来，在事务中有条件的执行（乐观锁）。
- UNWATCH：刷新一个事务中已被监视的所有key。如果执行EXEC 或者DISCARD， 则不需要手动执行UNWATCH 。

# 3.实战 Case
## 3.1 正常执行事务
```
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> set k1 v1
QUEUED
127.0.0.1:6379> set k2 v2
QUEUED
127.0.0.1:6379> mget k1 k2
QUEUED
127.0.0.1:6379> EXEC
1) OK
2) OK
3) 1) "v1"
   2) "v2"
```
> QUEUED：表示命令被加入到事务的执行队列中，等待执行。

## 3.2 主动放弃事务
```
127.0.0.1:6379> keys *
1) "k1"
2) "k2"
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> set k3 v3
QUEUED
127.0.0.1:6379> get k3
QUEUED
127.0.0.1:6379> DISCARD
OK
127.0.0.1:6379> keys *
1) "k1"
2) "k2"
```

## 3.3 异常导致事务整体失败
```
127.0.0.1:6379> keys *
1) "k1"
2) "k2"
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> set k3 v3
QUEUED
127.0.0.1:6379> gett k3
(error) ERR unknown command `gett`, with args beginning with: `k3`,
127.0.0.1:6379> set k4 v4
QUEUED
127.0.0.1:6379> EXEC
(error) EXECABORT Transaction discarded because of previous errors.
127.0.0.1:6379> keys *
1) "k1"
2) "k2"
```
> 在事务执行过程中，因为某个命令输入错误，或者其他原因导致发生 ERR ，则会导致整个事务执行失败。

## 3.4 单个命令失败不影响整体事务
```
127.0.0.1:6379> keys *
1) "k1"
2) "k2"
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> incr k1
QUEUED
127.0.0.1:6379> get k1
QUEUED
127.0.0.1:6379> EXEC
1) (error) ERR value is not an integer or out of range
2) "v1"
```
> 在事务提交后，由于 k1 中存储的值非数字，incr 命令执行会出错，这种情况不会影响事务整体效果，仅仅会影响incr 命令的效果。与上面的情况不同，incr 命令是在事务提交后执行的过程发生的异常情况，而 3.3 中的 gett 命令是在事务执行过程中发生的异常。

## 3.5 WATCH 监控
> 经典的转账案例：a 和 b 每人 100 元，a 向 b 转账 10 元

### 3.5.1 正常流程，无中间操作
```
127.0.0.1:6379> mset a 100 b 100
OK
127.0.0.1:6379> mget a b
1) "100"
2) "100"
127.0.0.1:6379> WATCH a
OK
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> DECRBY a 10
QUEUED
127.0.0.1:6379> INCRBY b 10
QUEUED
127.0.0.1:6379> EXEC
1) (integer) 90
2) (integer) 110
127.0.0.1:6379> mget a b
1) "90"
2) "110"
```

### 3.5.2 转账途中，发生中间操作
> a 扣款10 元后，在 b 增加 10 元之前，a 又消费 20 元。
```
127.0.0.1:6379> mset a 100 b 100
OK
127.0.0.1:6379> WATCH a
OK
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> DECRBY a 10
QUEUED
```
重新开启窗口，模拟 a 消费 20 元
```
127.0.0.1:6379> DECRBY a 20
(integer) 80
```
此时 a 向 b 转账流程继续执行
```
127.0.0.1:6379> INCRBY b 10
QUEUED
127.0.0.1:6379> EXEC
(nil)
```
> 事务提交后，返回结果为 nil ，表明此事务执行失败。

再次获取 a 和 b 的账户余额
```
127.0.0.1:6379> mget a b
1) "80"
2) "100"
```
> a 账户仅有消费 20 元的记录，a 和 b 账户均无转账 10 元记录。

### 3.5.3 小结
- Watch指令，类似乐观锁，事务提交时，如果Key的值已被别的客户端改变， 比如某个list已被别的客户端push/pop过了，整个事务队列都不会被执行
- 通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生了变化， EXEC命令执行的事务都将被放弃，同时返回Nullmulti-bulk应答以通知调用者事务执行失败